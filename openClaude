#!/usr/bin/env bash
# openClaude — Launch Claude Code with LiteLLM mixed-model routing
#
# Normal 'claude' → Bedrock-direct (unchanged ~/.claude/settings.json)
# 'openClaude' → LiteLLM proxy → Bedrock (Claude) + Bedrock Converse (Qwen for haiku slot)
#
# Uses CLAUDE_CONFIG_DIR to point at ~/.openClaude/ which has a derived
# settings.json (no CLAUDE_CODE_USE_BEDROCK, LiteLLM model aliases) while
# symlinking everything else back to ~/.claude/ so history/projects/etc are shared.

set -euo pipefail

# ── Configuration (override via env vars) ────────────────────────────
OPENCLAUDE_AWS_PROFILE="${OPENCLAUDE_AWS_PROFILE:-openclaude}"
OPENCLAUDE_AWS_REGION="${OPENCLAUDE_AWS_REGION:-us-west-2}"
LITELLM_PORT="${OPENCLAUDE_LITELLM_PORT:-4000}"
LITELLM_BEDROCK_PORT=$((LITELLM_PORT + 1))
LITELLM_CONFIG="$HOME/.litellm/config.yaml"
LITELLM_BEDROCK_CONFIG="$HOME/.litellm/config-bedrock.yaml"
OPEN_CLAUDE_DIR="$HOME/.openClaude"
CLAUDE_DIR="$HOME/.claude"

# ── Ensure LiteLLM configs reflect configured region ────────────────
for config in "$LITELLM_CONFIG" "$LITELLM_BEDROCK_CONFIG"; do
  if [[ -f "$config" ]]; then
    if [[ "$OSTYPE" == "darwin"* ]]; then
      sed -i '' "s/aws_region_name: .*/aws_region_name: $OPENCLAUDE_AWS_REGION/" "$config"
    else
      sed -i "s/aws_region_name: .*/aws_region_name: $OPENCLAUDE_AWS_REGION/" "$config"
    fi
  fi
done

# ── Kill stale LiteLLM processes that aren't on our ports ────────────
main_healthy=false
bedrock_healthy=false

if curl -s --max-time 2 "http://localhost:$LITELLM_PORT/health" >/dev/null 2>&1; then
  main_healthy=true
fi

if curl -s --max-time 2 "http://localhost:$LITELLM_BEDROCK_PORT/health" >/dev/null 2>&1; then
  bedrock_healthy=true
fi

if ! $main_healthy || ! $bedrock_healthy; then
  pkill -f "litellm.*--port" 2>/dev/null || true
  sleep 0.5
  main_healthy=false
  bedrock_healthy=false
fi

# ── Start LiteLLM instances if not already running ───────────────────
if ! command -v litellm >/dev/null 2>&1; then
  echo "Error: litellm not found. Install with: uv tool install 'litellm[proxy]'" >&2
  exit 1
fi

# Start Instance 2 (Bedrock-only) if not running
if ! $bedrock_healthy; then
  echo "Starting LiteLLM Bedrock instance on port $LITELLM_BEDROCK_PORT..."
  if [[ ! -f "$LITELLM_BEDROCK_CONFIG" ]]; then
    echo "Error: LiteLLM Bedrock config not found at $LITELLM_BEDROCK_CONFIG" >&2
    exit 1
  fi
  AWS_PROFILE="$OPENCLAUDE_AWS_PROFILE" nohup litellm --config "$LITELLM_BEDROCK_CONFIG" --port "$LITELLM_BEDROCK_PORT" >/tmp/litellm-bedrock.log 2>&1 &
  LITELLM_BEDROCK_PID=$!
  echo "LiteLLM Bedrock instance started (PID $LITELLM_BEDROCK_PID), waiting for health..."
  for i in {1..15}; do
    if curl -s --max-time 2 "http://localhost:$LITELLM_BEDROCK_PORT/health" >/dev/null 2>&1; then
      echo "LiteLLM Bedrock instance ready."
      bedrock_healthy=true
      break
    fi
    if ! kill -0 "$LITELLM_BEDROCK_PID" 2>/dev/null; then
      echo "Error: LiteLLM Bedrock instance failed to start. Check /tmp/litellm-bedrock.log" >&2
      exit 1
    fi
    sleep 1
  done
fi

# Start Instance 1 (Main proxy) if not running
if ! $main_healthy; then
  echo "Starting LiteLLM main proxy on port $LITELLM_PORT..."
  if [[ ! -f "$LITELLM_CONFIG" ]]; then
    echo "Error: LiteLLM config not found at $LITELLM_CONFIG" >&2
    exit 1
  fi
  # Instance 1 needs no AWS credentials - it only talks to Anthropic API or localhost:4001
  nohup litellm --config "$LITELLM_CONFIG" --port "$LITELLM_PORT" >/tmp/litellm.log 2>&1 &
  LITELLM_PID=$!
  echo "LiteLLM main proxy started (PID $LITELLM_PID), waiting for health..."
  for i in {1..15}; do
    if curl -s --max-time 2 "http://localhost:$LITELLM_PORT/health" >/dev/null 2>&1; then
      echo "LiteLLM main proxy ready."
      main_healthy=true
      break
    fi
    if ! kill -0 "$LITELLM_PID" 2>/dev/null; then
      echo "Error: LiteLLM main proxy failed to start. Check /tmp/litellm.log" >&2
      exit 1
    fi
    sleep 1
  done
fi

# ── Build ~/.openClaude/ config dir ──────────────────────────────────
mkdir -p "$OPEN_CLAUDE_DIR"

# Symlink everything from ~/.claude/ except settings.json files
for item in "$CLAUDE_DIR"/*; do
  base=$(basename "$item")
  case "$base" in
    settings.json*) continue ;;
  esac
  target="$OPEN_CLAUDE_DIR/$base"
  if [ -L "$target" ] && [ ! -e "$target" ]; then
    rm "$target"
  fi
  if [ ! -e "$target" ] && [ ! -L "$target" ]; then
    ln -s "$item" "$target"
  fi
done

# Also handle hidden files/dirs in ~/.claude/
for item in "$CLAUDE_DIR"/.*; do
  base=$(basename "$item")
  case "$base" in
    .|..) continue ;;
    settings.json*) continue ;;
  esac
  target="$OPEN_CLAUDE_DIR/$base"
  if [ -L "$target" ] && [ ! -e "$target" ]; then
    rm "$target"
  fi
  if [ ! -e "$target" ] && [ ! -L "$target" ]; then
    ln -s "$item" "$target"
  fi
done

# Generate derived settings.json from the user's existing ~/.claude/settings.json.
# Uses firstParty model names for Claude Code compatibility.
jq '
  .model = "claude-opus-4-6" |
  del(.awsCredentialExport) |
  del(.awsAuthRefresh) |
  .env = (.env |
    del(.CLAUDE_CODE_USE_BEDROCK) |
    del(.ANTHROPIC_API_KEY) |
    .ANTHROPIC_DEFAULT_OPUS_MODEL = "claude-opus-4-6" |
    .ANTHROPIC_DEFAULT_SONNET_MODEL = "claude-sonnet-4-5" |
    .ANTHROPIC_SMALL_FAST_MODEL = "qwen-3-coder" |
    .ANTHROPIC_DEFAULT_HAIKU_MODEL = "qwen-3-coder"
  )
' "$CLAUDE_DIR/settings.json" > "$OPEN_CLAUDE_DIR/settings.json"

# Seed .claude.json (auth state, theme, etc.) from home dir if openClaude's copy
# doesn't exist yet. After first copy, each mode maintains its own state independently.
if [ ! -f "$OPEN_CLAUDE_DIR/.claude.json" ]; then
  cp "$HOME/.claude.json" "$OPEN_CLAUDE_DIR/.claude.json" 2>/dev/null || true
fi

# ── Launch Claude Code through LiteLLM ──────────────────────────────
export CLAUDE_CONFIG_DIR="$OPEN_CLAUDE_DIR"
export ANTHROPIC_BASE_URL="http://localhost:$LITELLM_PORT"

# Clear vars that conflict with the LiteLLM flow
unset CLAUDE_CODE_USE_BEDROCK 2>/dev/null || true
unset CLAUDE_CODE_SUBAGENT_MODEL 2>/dev/null || true

exec "$HOME/.local/bin/claude" "$@"
